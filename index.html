// Advanced search parser - moved outside useCallback to avoid circular dependency
            const parseSearchQuery = (query) => {
                if (!query) return { terms: [], exclude: [], exact: [], wildcards: [], operators: [] };
                
                const tokens = [];
                let current = '';
                let inQuotes = false;
                let quoteChar = '';
                
                // Tokenize the query
                for (let i = 0; i < query.length; i++) {
                    const char = query[i];
                    
                    if (!inQuotes && (char === '"' || char === "'")) {
                        if (current.trim()) tokens.push(current.trim());
                        current = '';
                        inQuotes = true;
                        quoteChar = char;
                    } else if (inQuotes && char === quoteChar) {
                        if (current.trim()) tokens.push(`"${current.trim()}"`);
                        current = '';
                        inQuotes = false;
                        quoteChar = '';
                    } else if (!inQuotes && char === ' ') {
                        if (current.trim()) tokens.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if (current.trim()) tokens.push(current.trim());
                
                const result = {
                    terms: [],
                    exclude: [],
                    exact: [],
                    wildcards: [],
                    operators: []
                };
                
                for (let token of tokens) {
                    if (token.startsWith('-')) {
                        result.exclude.push(token.substring(1).toLowerCase());
                    } else if (token.startsWith('"') && token.endsWith('"')) {
                        result.exact.push(token.slice(1, -1).toLowerCase());
                    } else if (token.includes('*')) {
                        result.wildcards.push(token.toLowerCase());
                    } else if (['AND', 'OR', 'NOT'].includes(token.toUpperCase())) {
                        result.operators.push(token.toUpperCase());
                    } else {
                        result.terms.push(token.toLowerCase());
                    }
                }
                
                return result;
            };

            // Advanced search filter
            const searchFilter = useCallback((row, term) => {
                if (!term) return true;

                const basicFields = [
                    row.Naam,
                    row.Omschrijving,
                    row.Entiteitcode,
                    row.Attribuutcode,
                    row.Entiteitcode && row.Attribuutcode ? `${row.Entiteitcode}_${row.Attribuutcode}` : null
                ];

                // Add ANVA information if available
                const fullCode = row.Entiteitcode && row.Attribuutcode ? `${row.Entiteitcode}_${row.Attribuutcode}` : null;
                const anvaInfo = fullCode ? anvaData[fullCode] : null;
                if (anvaInfo) {
                    basicFields.push(anvaInfo.code);
                    basicFields.push(anvaInfo.omschrijving);
                }

                const searchContent = basicFields.filter(Boolean).join(' ').toLowerCase();
                const query = parseSearchQuery(term);
                
                // Handle simple case - just regular terms
                if (query.exact.length === 0 && query.exclude.length === 0 && 
                    query.wildcards.length === 0 && query.operators.length === 0) {
                    return query.terms.every(t => searchContent.includes(t));
                }
                
                let matches = true;
                
                // Check exact phrases
                for (const exact of query.exact) {
                    if (!searchContent.includes(exact)) {
                        matches = false;
                        break;
                    }
                }
                
                // Check excluded terms
                for (const exclude of query.exclude) {
                    if (searchContent.includes(exclude)) {
                        matches = false;
                        break;
                    }
                }
                
                // Check wildcards
                for (const wildcard of query.wildcards) {
                    const regex = new RegExp(wildcard.replace(/\*/g, '.*'), 'i');
                    const found = basicFields.some(field => 
                        field && regex.test(field.toLowerCase())
                    );
                    if (!found) {
                        matches = false;
                        break;
                    }
                }
                
                // Check regular terms
                for (const t of query.terms) {
                    if (!searchContent.includes(t)) {
                        matches = false;
                        break;
                    }
                }
                
                return matches;
            }, [anvaData]);
